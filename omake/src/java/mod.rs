use std::fs::{DirEntry, File, FileType, ReadDir};
use std::io::{Error, Write};
use std::ops::{Generator, GeneratorState};
use std::path::{Path, PathBuf};
use std::pin::Pin;
use std::{fs, io};

use crate::java::plugin::{ClassPathEntry, JavaData, JavaExtension};
use crate::task::{input_changed, input_changed_multi, Context, PathDep, Task};

pub mod plugin;

#[derive(Debug)]
pub struct JavaTask {
    input_root: PathBuf,
    output_root: PathBuf,
    class: PathBuf,
}

impl Task for JavaTask {
    fn make(&self, ctx: &Context) -> Result<(), String> {
        let c = ctx.get_extension::<JavaExtension>().unwrap();
        let temp_dir = ctx.create_temp_dir();
        let input_file = self.input_file();
        c.exec_javac(&input_file, &temp_dir).unwrap();

        Ok(())
    }

    fn inputs(&self, ctx: &Context) -> Vec<PathDep> {
        let mut vec = Vec::with_capacity(1);
        let c = ctx.get_extension::<JavaExtension>().unwrap();

        vec.push(PathDep::new(self.input_file()));

        let manifest_outdated = input_changed(&self.input_file(), &self.manifest_path()).unwrap();

        if manifest_outdated {
            // We don't know what classes this class uses, so we'll just assume
            // it needs every other dependency on the classpath compiled
            // This will break for tasks that generate java files, but let's fix
            // that later.
            vec.extend(c.class_path().iter().map(|el| match el {
                ClassPathEntry::File(path) => PathDep::new(path.clone()),
                ClassPathEntry::Dir(path) => PathDep::new(path.clone()).with_dir(true, "*.class"),
            }));
        } else {
            // We know exactly which classes this reads from; we just need to
            // map them to files.
        }

        vec
    }

    fn outputs(&self, ctx: &Context) -> Vec<PathDep> {
        let mut vec = Vec::with_capacity(2);
        let outfile = self.manifest_path();

        let manifest_outdated = input_changed_multi(&self.inputs(ctx), &[&outfile]).unwrap();

        if manifest_outdated {
            // We don't know what this class outputs, especially if we never had
            // an outfile. You might think that there's an 1:1 mapping from
            // X.java to X.class, but that's not necessarily the case. Compiling
            // the file might yield more than just X.class, and X.class might
            // not even be generated, since the class file inside the source
            // does not need to equal the file name if the class is not public.
            // So here, we just say this task outputs _any_ file in the output
            // root.
            vec.push(PathDep::new(self.output_root.clone()).with_dir(true, "*.class"));
        } else {
            // Since this task isn't out of date, we know exactly what files
            // it outputs, namely those recorded in the manifest, one on each
            // line.
            let outfile_content = std::fs::read_to_string(&outfile).unwrap();
            vec.extend(
                outfile_content
                    .lines()
                    .filter_map(|el| el.strip_prefix("-> "))
                    .map(|el| PathBuf::from(el).into()),
            );
        }

        // insert the outfile at position 0 to mark it as the "main" output.
        vec.insert(0, outfile.into());

        vec
    }

    fn needs_exec(&self, ctx: &Context) -> bool {
        input_changed(&self.input_file(), &self.manifest_path()).unwrap_or(true)
    }
}

impl JavaTask {
    fn new(input_root: PathBuf, output_root: PathBuf, class: PathBuf) -> Self {
        JavaTask {
            input_root,
            output_root,
            class,
        }
    }

    fn manifest_path(&self) -> PathBuf {
        let mut path = self.output_root.join(&self.class);
        path.set_extension("omf");
        path
    }

    fn input_file(&self) -> PathBuf {
        let mut path = self.input_root.join(&self.class);
        path.set_extension("java");
        path
    }

    fn write_manifest(&self, dependencies: &[&str], outputs: &[&Path]) -> io::Result<()> {
        let mut file = File::create(self.manifest_path())?;
        writeln!(file, "; Origami Manifest")?;
        writeln!(
            file,
            "; Autogenerated file for class '{}'.",
            self.class.to_str().unwrap()
        )?;

        writeln!(file, "; Do not edit.")?;

        if !dependencies.is_empty() {
            writeln!(file)?;
            writeln!(file, "; Inputs")?;

            for dep in dependencies {
                writeln!(file, "<- {}", dep)?;
            }
        }

        if !outputs.is_empty() {
            writeln!(file)?;
            writeln!(file, "; Outputs")?;

            for output in outputs {
                writeln!(file, "-> {}", output.to_str().unwrap())?;
            }
        }

        Ok(())
    }
}

fn find_files<'a, P: AsRef<Path> + 'a>(
    path: P,
) -> FindFiles<impl Generator<Yield = io::Result<PathBuf>, Return = ()>> {
    let path = path.as_ref().to_path_buf();
    let generator = move || {
        let rd = match fs::read_dir(path) {
            Ok(rd) => rd,
            Err(e) => {
                yield Err(e);
                return;
            }
        };

        let mut stack = vec![rd];

        while let Some(last) = stack.pop() {
            for entry in last {
                let entry = match entry {
                    Ok(entry) => entry,
                    Err(e) => {
                        yield Err(e);
                        continue;
                    }
                };

                let ft = match entry.file_type() {
                    Ok(ft) => ft,
                    Err(e) => {
                        yield Err(e);
                        continue;
                    }
                };

                if ft.is_dir() {
                    match fs::read_dir(entry.path()) {
                        Ok(rd) => {
                            stack.push(rd);
                        }
                        Err(e) => yield Err(e),
                    }
                } else {
                    yield Ok(entry.path());
                }
            }
        }
    };

    FindFiles {
        generator: Box::pin(generator),
    }
}

struct FindFiles<G> {
    generator: Pin<Box<G>>,
}

impl<G> Iterator for FindFiles<G>
where
    G: Generator<Yield = io::Result<PathBuf>, Return = ()>,
{
    type Item = io::Result<PathBuf>;

    fn next(&mut self) -> Option<Self::Item> {
        let r = self.generator.as_mut().resume(());
        match r {
            GeneratorState::Yielded(v) => Some(v),
            GeneratorState::Complete(()) => None,
        }
    }
}
