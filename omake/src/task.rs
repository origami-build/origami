use std::cmp::{max, min};
use std::fmt::Debug;
use std::ops::Deref;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicU32, Ordering};
use std::{fs, io};

pub use pathdep::*;

use crate::project::Project;

mod pathdep;

pub trait Task: Debug {
    fn make(&self, ctx: &Context) -> Result<(), String>;

    fn inputs(&self, ctx: &Context) -> Vec<PathDep>;

    fn outputs(&self, ctx: &Context) -> Vec<PathDep>;

    /// Gets called to check if this task is out of date based on all
    /// dependencies returned from [`Task::inputs()`] that are not generated by another
    /// task. Usually, you want to just call [`input_changed()`] or a variant
    /// thereof here.
    fn needs_exec(&self, ctx: &Context) -> bool;
}

pub struct Context<'a> {
    project: &'a Project,
}

impl<'a> Context<'a> {
    pub fn new(project: &'a Project) -> Self {
        Context { project }
    }

    pub fn create_temp_dir(&self) -> TempDir {
        TempDir::create_in(self.project.build_root()).unwrap()
    }

    pub fn get_extension<T: 'static>(&self) -> Option<&T> {
        self.project.extensions().get()
    }

    pub fn project(&self) -> &Project {
        self.project
    }
}

#[derive(Debug)]
pub struct TempDir {
    inner: PathBuf,
}

impl TempDir {
    pub fn create(path: &Path) -> io::Result<Self> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::create_dir(path)?;
        Ok(TempDir {
            inner: path.to_path_buf(),
        })
    }

    pub fn create_in(parent: &Path) -> io::Result<Self> {
        fs::create_dir_all(parent)?;

        loop {
            static COUNTER: AtomicU32 = AtomicU32::new(0);

            let idx = COUNTER.fetch_add(1, Ordering::Relaxed);
            let s = format!("{:08X}", idx);
            let path = parent.join(s);

            match fs::create_dir(&path) {
                Ok(_) => break Ok(TempDir { inner: path }),
                Err(e) if e.kind() == io::ErrorKind::AlreadyExists => {}
                Err(e) => break Err(e),
            }
        }
    }
}

impl Deref for TempDir {
    type Target = Path;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl Drop for TempDir {
    fn drop(&mut self) {
        let _ = fs::remove_dir_all(&self.inner);
    }
}

pub fn input_changed_multi<P1, P2>(inputs: &[P1], outputs: &[P2]) -> io::Result<bool>
where
    P1: PathDepLike,
    P2: PathDepLike,
{
    let mut mtime_inputs = None;
    let mut mtime_outputs = None;

    for input in inputs {
        let input = input.to_path_dep();

        for path in input.paths() {
            let metadata = fs::metadata(path)?;
            let mtime = metadata.modified()?;

            mtime_inputs = match mtime_inputs {
                None => Some(mtime),
                Some(old_mtime) => Some(max(old_mtime, mtime)),
            }
        }
    }

    for output in outputs {
        let output = output.to_path_dep();

        for path in output.paths() {
            let metadata = fs::metadata(path)?;
            let mtime = metadata.modified()?;

            mtime_outputs = match mtime_outputs {
                None => Some(mtime),
                Some(old_mtime) => Some(min(old_mtime, mtime)),
            }
        }
    }

    match (mtime_inputs, mtime_outputs) {
        (Some(mtime_inputs), Some(mtime_outputs)) => Ok(mtime_inputs > mtime_outputs),
        _ => Ok(true),
    }
}

pub fn input_changed(input: &Path, output: &Path) -> io::Result<bool> {
    let input_meta = fs::metadata(input)?;
    let output_meta = fs::metadata(output)?;
    Ok(input_meta.modified()? > output_meta.modified()?)
}
