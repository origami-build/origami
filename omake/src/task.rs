use std::ffi::{OsStr, OsString};
use std::fmt::Debug;
use std::ops::Deref;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicU32, Ordering};
use std::{fs, io};

use crate::project::Project;

pub trait Task: Debug {
    fn make(&self, ctx: &Context) -> Result<(), String>;

    fn inputs(&self, ctx: &Context) -> Vec<PathDep>;

    fn outputs(&self, ctx: &Context) -> Vec<PathDep>;

    /// Gets called to check if this task is out of date based on all
    /// dependencies returned from [[inputs]] that are not generated by another
    /// task. Usually, you want to just call [[input_changed]] or a variant
    /// thereof here.
    fn needs_exec(&self, ctx: &Context) -> bool;
}

pub struct Context<'a> {
    project: &'a Project,
}

impl<'a> Context<'a> {
    pub fn new(project: &'a Project) -> Self {
        Context { project }
    }

    pub fn create_temp_dir(&self) -> TempDir {
        TempDir::create_in(self.project.build_root()).unwrap()
    }

    pub fn get_extension<T: 'static>(&self) -> Option<&T> {
        self.project.extensions().get()
    }

    pub fn project(&self) -> &Project {
        self.project
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PathDep {
    base: PathBuf,
    optional: bool,
    dt: DepType,
}

#[derive(Debug, Clone, Eq, PartialEq)]
enum DepType {
    File,
    Dir(bool, OsString),
}

impl PathDep {
    pub fn new(buf: PathBuf) -> Self {
        PathDep {
            base: buf,
            optional: false,
            dt: DepType::File,
        }
    }

    pub fn with_optional(mut self) -> Self {
        self.optional = true;
        self
    }

    pub fn with_dir<S: AsRef<OsStr>>(mut self, recursive: bool, matches: S) -> Self {
        self.dt = DepType::Dir(recursive, matches.as_ref().to_os_string());
        self
    }

    pub fn base(&self) -> &Path {
        &self.base
    }
}

pub trait PathDepLike {
    fn to_path_dep(&self) -> PathDep;

    fn base(&self) -> &Path;

    fn optional(&self) -> bool;

    fn path_matches(&self, path: &Path) -> bool;
}

impl PathDepLike for PathBuf {
    fn to_path_dep(&self) -> PathDep {
        PathDep::new(self.clone())
    }

    fn base(&self) -> &Path {
        &self
    }

    fn optional(&self) -> bool {
        false
    }

    fn path_matches(&self, path: &Path) -> bool {
        self == path
    }
}

impl From<PathBuf> for PathDep {
    fn from(pb: PathBuf) -> Self {
        PathDep::new(pb)
    }
}

impl PathDepLike for &Path {
    fn to_path_dep(&self) -> PathDep {
        PathDep::new(self.to_path_buf())
    }

    fn base(&self) -> &Path {
        self
    }

    fn optional(&self) -> bool {
        false
    }

    fn path_matches(&self, path: &Path) -> bool {
        self == &path
    }
}

impl PathDepLike for PathDep {
    fn to_path_dep(&self) -> PathDep {
        self.clone()
    }

    fn base(&self) -> &Path {
        &self.base
    }

    fn optional(&self) -> bool {
        self.optional
    }

    fn path_matches(&self, path: &Path) -> bool {
        match &self.dt {
            DepType::File => self.base == path,
            DepType::Dir(recursive, pattern) => unimplemented!(),
        }
    }
}

impl<T> PathDepLike for &T
where
    T: PathDepLike,
{
    fn to_path_dep(&self) -> PathDep {
        (*self).to_path_dep()
    }

    fn base(&self) -> &Path {
        (*self).base()
    }

    fn optional(&self) -> bool {
        (*self).optional()
    }

    fn path_matches(&self, path: &Path) -> bool {
        (*self).path_matches(path)
    }
}

#[derive(Debug)]
pub struct TempDir {
    inner: PathBuf,
}

impl TempDir {
    pub fn create(path: &Path) -> io::Result<Self> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::create_dir(path)?;
        Ok(TempDir {
            inner: path.to_path_buf(),
        })
    }

    pub fn create_in(parent: &Path) -> io::Result<Self> {
        fs::create_dir_all(parent)?;

        loop {
            static COUNTER: AtomicU32 = AtomicU32::new(0);

            let idx = COUNTER.fetch_add(1, Ordering::Relaxed);
            let s = format!("{:08X}", idx);
            let path = parent.join(s);

            match fs::create_dir(&path) {
                Ok(_) => break Ok(TempDir { inner: path }),
                Err(e) if e.kind() == io::ErrorKind::AlreadyExists => {}
                Err(e) => break Err(e),
            }
        }
    }
}

impl Deref for TempDir {
    type Target = Path;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl Drop for TempDir {
    fn drop(&mut self) {
        let _ = fs::remove_dir_all(&self.inner);
    }
}

pub fn input_changed_multi<P1, P2>(inputs: &[P1], outputs: &[P2]) -> io::Result<bool>
where
    P1: PathDepLike,
    P2: PathDepLike,
{
    outputs
        .iter()
        .flat_map(|o| inputs.iter().map(move |i| (i, o)))
        .fold(Ok(false), |acc, (i, o)| match acc {
            x @ Ok(true) => x,
            Ok(false) => input_changed_pd(i, o),
            x @ Err(_) => x,
        })
}

pub fn input_changed_pd<P1, P2>(input: P1, output: P2) -> io::Result<bool>
where
    P1: PathDepLike,
    P2: PathDepLike,
{
    unimplemented!()
}

pub fn input_changed(input: &Path, output: &Path) -> io::Result<bool> {
    let input_meta = fs::metadata(input)?;
    let output_meta = fs::metadata(output)?;
    Ok(input_meta.modified()? > output_meta.modified()?)
}
